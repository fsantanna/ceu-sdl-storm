#define DROPS_PERSEC_MIN  10
#define DROPS_PERSEC_MAX 100
#define DROPS_DECAY_MS 2000
#define DROPS_LEN 2

code/await Drop (var IPhysics&& cloud) => void
do
    var SDL_Rect rct = val SDL_Rect((_rand()%cloud:x.len + cloud:x.pos) as int,
                                    (cloud:y.pos + cloud:y.len) as int,
                                    DROPS_LEN,
                                    5);
    var float vx = cloud:x.vel;

    var& IPhysics drop;
    spawn Physics(rct, SDL_Color(0x98, 0xC1, 0xE4, 0))
            => (drop);
    drop.x.vel  = vx;
    drop.x.drag = 0.98;
    drop.y.drag = 0.98;
    drop.y.acc  = 500;

    event void decay;
    par/or do
        var int dt;
        every dt in SDL_DT do
            if drop.y.pos > WIN_H-DROPS_LEN then
                drop.y.pos = WIN_H-DROPS_LEN;
                drop.y.vel = -(drop.y.vel*2/3);
                emit decay;
            end
            if (drop.x.pos > WIN_W) or (drop.x.pos < 0) or (drop.y.pos < 0) then
                break;
            end

            var int abs_vx = _abs(drop.x.vel);
            var int abs_vy = _abs(drop.y.vel);
            if abs_vx > abs_vy then
                drop.x.len = DROPS_LEN * (1 + (abs_vx-abs_vy)/100);
                drop.y.len = DROPS_LEN;
            else
                drop.x.len = DROPS_LEN;
                drop.y.len = DROPS_LEN * (1 + (abs_vy-abs_vx)/100);
            end

            var int tmax = DROPS_LEN * 4;
            if drop.x.len > tmax then
                drop.x.len = tmax;
            end
            if drop.y.len > tmax then
                drop.y.len = tmax;
            end
        end
    with
        await decay;
        await (DROPS_DECAY_MS)ms;
    end
end

code/await Cloud (pool&[] Drop drops, var int dps)
                    => (var& IPhysics cloud, var& int dps_out)
                        => FOREVER
do
    dps_out = &dps;

    var int maxy = 2 * 1000 / DROPS_PERSEC_MIN;

    var int freq_ini = 1000 / dps;
    var int freq_cur = freq_ini;
    var int ty = maxy - freq_cur*2;
    if ty < 1 then
        ty = 1;
    end

    var int w = 100 + _rand()%100;
    var SDL_Rect rct = val SDL_Rect(-w, ty, 100+_rand()%100, 20+_rand()%50);

    var int v = 200 - (200*ty / maxy);
    var SDL_Color clr = val SDL_Color(v, (v*0.95) as int, v, 0);

    var int vx = 10 + _rand()%50;

    var& IPhysics cloud_;
    spawn Physics(rct, clr) => (cloud_);
    cloud = &cloud_;

    cloud_.x.vel = vx;
    par do
        var int dt;
        every dt in SDL_DT do
            if cloud_.x.pos > WIN_W then
                cloud_.x.pos = -cloud_.x.len;
            end
        end
    with
        every (freq_cur)ms do
            spawn Drop(&&cloud_) in drops;
        end
    with
        every 50ms do
            freq_ini = 1000 / dps;
            if freq_ini == freq_cur then
                continue;
            end

            if _abs(freq_ini - freq_cur) < 1 then
                freq_cur = freq_ini;
            else/if (freq_ini - freq_cur) > 0 then
                freq_cur = freq_cur + 1;
            else
                freq_cur = freq_cur - 1;
            end

            ty = maxy - freq_cur*2;
            if ty < 1 then
                ty = 1;
            end
            cloud_.y.pos = ty;
            cloud_.clr = val SDL_Color(200-(200*ty/maxy),
                                       ((cloud_.clr.r as int)*0.95) as u8,
                                       cloud_.clr.r,
                                       cloud_.clr.a);
        end
    end
end

code/await Boom (var int x) => void
do
    var int radius = 80;
    var SDL_Rect rct = val SDL_Rect(x - radius,
                                    (WIN_H + radius*0.2 - radius) as int,
                                    radius*2,
                                    radius*2);

    //_Mix_PlayChannel(-1, outer.snd_explosion, 0);
    watching 100ms do
        every SDL_REDRAW do
            _SDL_SetRenderDrawColor(&&outer.ren, 0xFF, 0x9D, 0x46, 0x00);
            _SDL_RenderFillRect(&&outer.ren, (&&rct as _SDL_Rect&&));
        end
#if 0
        par do
            var float d = DIM;
            var float v = 40 * DIM;
            var int dt;
            every dt in SDL_DT do
                d = d + v*dt/1000;
                obj.rect.w = d as int;
                obj.rect.h = d as int;
            end
        with
            every SDL_REDRAW do
                _filledCircleRGBA(outer.ren, obj.rect.x,obj.rect.y,obj.rect.w,
                                             0xFF,0x00,0x00,0xFF);
            end
        end
#endif
    end

end

code/await Light (pool&[] Boom     booms,
                  pool&[] Light    lights,
                  var     Vector2D pos_ini,
                  var     int?     direction,
                  var     int?     magnitude,
                  var     bool?    is_fork,
                 ) => void
do
    var int dir = 270;
    if direction? then
        dir = direction!;
    end

    var int mag = 50;
    if magnitude? then
        mag = magnitude!;
    end

    var bool fork = false;
    if is_fork? then
        fork = is_fork!;
    end

    var int chaos = 30;
	var float d = PI * (dir - chaos + _rand()%(chaos*2)) / 180.0;
    var Vector2D pos_end = val Vector2D(pos_ini.x + (_cos(d) * mag),
	                                    pos_ini.y - (_sin(d) * mag));

    watching 150ms do
        par do
            if pos_end.y >= WIN_H then
                if not fork then
                    spawn Boom((pos_ini.x + pos_end.x)/2) in booms;
                end
            else/if mag > 5 then
                await 20ms;

                var int m = mag;
                if fork then
                    m = (mag * 0.75) as int;
                end
                spawn Light(&booms, &lights, pos_end, dir, m, fork) in lights;

                if (_rand()%WIN_H) > pos_ini.y then
                    spawn Light(&booms, &lights, pos_ini, _rand()%180+180, (mag*0.5) as int, true)
                        in lights;
                end
            end
            await FOREVER;
        with
            every SDL_REDRAW do
                _SDL_SetRenderDrawColor(&&outer.ren, 0xEA, 0xD7, 0xFF, 0 );
                _SDL_RenderDrawLine(&&outer.ren,
                                    pos_ini.x, pos_ini.y,
                                    pos_end.x, pos_end.y);
            end
        end
    end
end

code/await Storm (void) => void
do
    pool[] Drop  drops;
    pool[] Cloud clouds;
    pool[] Light lights;
    pool[] Boom  booms;

    var int dps_cur = 0;

    loop i in [0 -> 3[ do
        var int dps = (_rand() % (DROPS_PERSEC_MAX+1-dps_cur)) + DROPS_PERSEC_MIN;
        dps_cur = dps_cur + dps;
        if dps_cur > DROPS_PERSEC_MAX then
            dps_cur = DROPS_PERSEC_MAX;
        end
        spawn Cloud(&drops, dps) in clouds;
    end

    par do
        every (_rand()%10 + 1)s do
            var& int dps_cloud;
            loop (_,dps_cloud) in clouds do
                if _rand()%3 == 0 then
                    continue;
                end

                dps_cur = dps_cur - dps_cloud;
                if dps_cur < DROPS_PERSEC_MIN then
                    dps_cur = DROPS_PERSEC_MIN;
                end

                var int dps = _rand()%(DROPS_PERSEC_MAX+1-dps_cur) + DROPS_PERSEC_MIN;
                dps_cur = dps_cur + dps;
                if dps_cur > DROPS_PERSEC_MAX then
                    dps_cur = DROPS_PERSEC_MAX;
                end

                dps_cloud = dps;
            end
            _printf("\nGotas por Segundo atual: %d/%d\n",dps_cur,DROPS_PERSEC_MAX);
        end
    with
        every (_rand()%3)s do
            var& IPhysics cloud1;//, cloud2;
            loop (cloud1,_) in clouds do
                //loop (cloud2,_) in clouds do
                    spawn Light(&booms, &lights,
                                Vector2D(cloud1.x.pos as int, cloud1.y.pos as int),
                                _,_,_)
                        in lights;
                    break;
                //end
            end
        end
    end
end
