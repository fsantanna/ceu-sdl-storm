#define PI 3.14159265

#define DROPS_PERSEC_MIN  10
#define DROPS_PERSEC_MAX 100
#define DROPS_DECAY_MS 2000

data Vector2D with
    var int x,y;
end;

data Axis with
    var float pos;
    var int   len;
    var float vel;
    var float acc;
    var float drag;
end

data IPhysics with
    var Axis x;
    var Axis y;
    var SDL_Color clr;
end

code/await Physics (var SDL_Rect rct, var SDL_Color clr)
                    => (var& IPhysics physics)
                        => void
do
    var IPhysics phys_ = val IPhysics(
                                Axis(rct.x, rct.w, 0, 0, 0),
                                Axis(rct.y, rct.h, 0, 0, 0),
                                clr,
                             );
    physics = &phys_;

    par do
        var int dt_ = _;
        every dt_ in SDL_DT do
            var float dt = (dt_ as float)/1000;
            phys_.x.vel = (phys_.x.vel + phys_.x.acc*dt)
                            * (1 - phys_.x.drag*dt);
            phys_.y.vel = (phys_.y.vel + phys_.y.acc*dt)
                            * (1 - phys_.y.drag*dt);
            phys_.x.pos = phys_.x.pos + phys_.x.vel*dt;
            phys_.y.pos = phys_.y.pos + phys_.y.vel*dt;
        end
    with
        every SDL_REDRAW do
            _SDL_SetRenderDrawColor(outer.ren,
                                    phys_.clr.r,
                                    phys_.clr.g,
                                    phys_.clr.b,
                                    phys_.clr.a);
            var SDL_Rect r = val SDL_Rect(phys_.x.pos as int,
                                          phys_.y.pos as int,
                                          phys_.x.len as int,
                                          phys_.y.len as int);
            _SDL_RenderFillRect(outer.ren, (&&r as _SDL_Rect&&));
        end
    end
end

#define DROP_LEN 2

code/await Drop (var& IPhysics cloud) => void
do
    var SDL_Rect rct = val SDL_Rect((_rand()%cloud.x.len + cloud.x.pos) as int,
                                    (cloud.y.pos + cloud.y.len) as int,
                                    DROP_LEN,
                                    5);
    var& IPhysics drop;
    watching Physics(rct, SDL_Color(0x98, 0xC1, 0xE4, 0))
                => (drop)
    do
        drop.x.vel  = cloud.x.vel;
        drop.x.drag = 0.98;
        drop.y.drag = 0.98;
        drop.y.acc  = 500;

        event void decay;
        par/or do
            loop do
                var int dt = await SDL_DT;
                if drop.y.pos > WIN_H-DROP_LEN then
                    drop.y.pos = WIN_H-DROP_LEN;
                    drop.y.vel = -(drop.y.vel*2/3);
                    emit decay;
                end
                if (drop.x.pos > WIN_W) or (drop.y.pos < 0) or (drop.x.pos < 0) then
                    escape;
                end

                var int abs_vx = _abs(drop.x.vel);
                var int abs_vy = _abs(drop.y.vel);
                if abs_vx > abs_vy then
                    drop.x.len = DROP_LEN * (1 + (abs_vx-abs_vy)/100);
                    drop.y.len = DROP_LEN;
                else
                    drop.x.len = DROP_LEN;
                    drop.y.len = DROP_LEN * (1 + (abs_vy-abs_vx)/100);
                end

                var int tmax = DROP_LEN * 4;
                if drop.x.len > tmax then
                    drop.x.len = tmax;
                end
                if drop.y.len > tmax then
                    drop.y.len = tmax;
                end
            end
        with
            await decay;
            await (DROPS_DECAY_MS)ms;
        end
    end
end

code/await Cloud (pool&[] Drop drops, var int dps)
                    => (var& IPhysics cloud, var& int dps_out)
                        => void
do
    dps_out = &dps;

    var int maxy = 2 * 1000 / DROPS_PERSEC_MIN;

    var int freq_ini = 1000 / dps;
    var int freq_cur = freq_ini;
    var int ty = maxy - freq_cur*2;
    if ty < 1 then
        ty = 1;
    end

    var int w = 100 + _rand()%100;
    var SDL_Rect rct = val SDL_Rect(-w, ty, 100+_rand()%100, 20+_rand()%50);

    var int v = 200 - (200*ty / maxy);
    var SDL_Color clr = val SDL_Color(v, (v*0.95) as int, v, 0);

    var int vx = 10 + _rand()%50;

    var& IPhysics cloud_;
    watching Physics(rct, clr) => (cloud_)
    do
        cloud = &cloud_;

        cloud_.x.vel = vx;
        par do
            var int dt;
            every dt in SDL_DT do
                if cloud_.x.pos > WIN_W then
                    cloud_.x.pos = -cloud_.x.len;
                end
            end
        with
            every (freq_cur)ms do
                spawn Drop(&cloud_) in drops;
            end
        with
            loop do
                await 50ms;
                freq_ini = 1000 / dps;
                if freq_ini == freq_cur then
                    continue;
                end

                if _abs(freq_ini - freq_cur) < 1 then
                    freq_cur = freq_ini;
                else/if (freq_ini - freq_cur) > 0 then
                    freq_cur = freq_cur + 1;
                else
                    freq_cur = freq_cur - 1;
                end

                ty = maxy - freq_cur*2;
                if ty < 1 then
                    ty = 1;
                end
                cloud_.y.pos = ty;
                cloud_.clr = val SDL_Color(200-(200*ty/maxy),
                                           ((cloud_.clr.r as int)*0.95) as u8,
                                           cloud_.clr.r,
                                           cloud_.clr.a);
            end
        end
    end
end

code/await Explosion (var int x) => void
do
    var int radius = 80;
    var SDL_Rect rct = val SDL_Rect(x - radius,
                                    (WIN_H + radius*0.2 - radius) as int,
                                    radius*2,
                                    radius*2);

    // explode 40w/s
    //_Mix_PlayChannel(-1, outer.snd_explosion, 0);
    watching 100ms do
        every SDL_REDRAW do
            _SDL_SetRenderDrawColor(outer.ren, 0xFF, 0x9D, 0x46, 0x00);
            _SDL_RenderFillRect(outer.ren, (&&rct as _SDL_Rect&&));
        end
#if 0
        par do
            var float d = DIM;
            var float v = 40 * DIM;
            var int dt;
            every dt in SDL_DT do
                d = d + v*dt/1000;
                obj.rect.w = d as int;
                obj.rect.h = d as int;
            end
        with
            every SDL_REDRAW do
                _filledCircleRGBA(outer.ren, obj.rect.x,obj.rect.y,obj.rect.w,
                                             0xFF,0x00,0x00,0xFF);
            end
        end
#endif
    end

end

code/await Light (pool&[] Light    lights,
                  var     Vector2D pos_ini,
                  var     int?     direction,
                  var     int?     magnitude,
                  var     bool?    is_fork,
                 ) => void
do
    var int dir = 270;
    if direction? then
        dir = direction!;
    end

    var int mag = 50;
    if magnitude? then
        mag = magnitude!;
    end

    var bool fork = false;
    if is_fork? then
        fork = is_fork!;
    end

    var int chaos = 30;
	var float d = PI * (dir - chaos + _rand()%(chaos*2)) / 180.0;
    var Vector2D pos_end = val Vector2D(pos_ini.x + (_cos(d) * mag),
	                                    pos_ini.y - (_sin(d) * mag));

    watching 150ms do
        par do
            if pos_end.y >= WIN_H then
                if not fork then
                    await Explosion((pos_ini.x + pos_end.x)/2);
                end
            else/if mag > 5 then
                await 20ms;

                var int m = mag;
                if fork then
                    m = (mag * 0.9) as int;
                end
                spawn Light(&lights, pos_end, dir, m, fork) in lights;

                if (_rand()%WIN_H) > pos_ini.y then
                    spawn Light(&lights, pos_ini, _rand()%180+180, (mag*0.5) as int, true)
                        in lights;
                end
            end
        with
            every SDL_REDRAW do
                _SDL_SetRenderDrawColor(outer.ren, 0xEA, 0xD7, 0xFF, 0 );
                _SDL_RenderDrawLine(outer.ren,
                                    pos_ini.x, pos_ini.y,
                                    pos_end.x, pos_end.y);
            end
        end
    end
end

code/await Storm (void) => void
do
    pool[] Drop  drops;
    pool[] Cloud clouds;
    pool[] Light lights;

    var int dps_cur = 0;

    loop i in [0 -> 3[ do
        var int dps = (_rand() % (DROPS_PERSEC_MAX-dps_cur)) + DROPS_PERSEC_MIN;
        if dps < 0 then
            dps = 1;
        end
        dps_cur = dps_cur + dps;

        spawn Cloud(&drops, dps) in clouds;
    end

    par do
        every (_rand()%10 + 1)s do
            var& int dps_cloud;
            loop (_,dps_cloud) in clouds do
                if _rand()%3 > 0 then
                    dps_cur = dps_cur - dps_cloud;
                    if dps_cur > DROPS_PERSEC_MAX then
                        dps_cur = DROPS_PERSEC_MAX;
                    else/if dps_cur < DROPS_PERSEC_MIN then
                        dps_cur = DROPS_PERSEC_MIN;
                    end

                    var int dps = _rand()%(DROPS_PERSEC_MAX+1-dps_cur) + DROPS_PERSEC_MIN;
                    if dps < 0 then
                        dps = 1;
                    end
                    dps_cur = dps_cur + dps;
                    dps_cloud = dps;
                end
            end
            _printf("\nGotas por Segundo atual: %d/%d\n",dps_cur,DROPS_PERSEC_MAX);
        end
    with
        every 2s do
            var& IPhysics cloud;
            loop (cloud,_) in clouds do
                spawn Light(&lights,
                            Vector2D(cloud.x.pos as int, cloud.y.pos as int),
                            _,_,_)
                    in lights;
            end
        end
    end
end

code/await Wheel (var& IPhysics car, var Vector2D offset) => void
do
    var int radius = 15;
    var float esp = (2 * PI / 12);
    var float pos = 0;

    par do
        var int dt = _;
        every dt in SDL_DT do
            var int s = do
                if car.x.vel >= 0 then
                    escape  1;
                else
                    escape -1;
                end
            end;

            var float mod = _sqrt(_pow(car.x.vel,2) + _pow(car.y.vel,2));
            pos = pos + (s * mod * dt / 1000 / radius);
        end
    with
        every SDL_REDRAW do
            _SDL_SetRenderDrawColor(outer.ren, 0xFF, 0x9D, 0x46, 0x00);
            loop i in [0 -> 12[ do
                var SDL_Rect r =
                    val SDL_Rect(
                        (car.x.pos + offset.x + (radius * _cos(i*esp + pos))) as int,
                        (car.y.pos + offset.y + (radius * _sin(i*esp + pos))) as int,
                        5, 5
                    );
                _SDL_RenderFillRect(outer.ren, (&&r as _SDL_Rect&&));
            end
        end
    end
end

code/await Car (void) => void
do
    var& IPhysics car;
    watching Physics(SDL_Rect(320,430, 60,30), SDL_Color(0x3B,0xBC,0x48,0))
                => (car)
    do
        spawn Wheel(&car, Vector2D(        0, car.y.len));
        spawn Wheel(&car, Vector2D(car.x.len, car.y.len));

        car.x.drag = 0.95;
        car.y.drag = 0.95;

        par do
            loop do
                var _SDL_KeyboardEvent&& key;
                key = await SDL_KEYDOWN until key:keysym.sym==_SDLK_LEFT;
                car.x.acc = -400;
                key = await SDL_KEYUP   until key:keysym.sym==_SDLK_LEFT;
                car.x.acc = 0;
            end
        with
            loop do
                var _SDL_KeyboardEvent&& key;
                key = await SDL_KEYDOWN until key:keysym.sym==_SDLK_RIGHT;
                car.x.acc = 400;
                key = await SDL_KEYUP   until key:keysym.sym==_SDLK_RIGHT;
                car.x.acc = 0;
            end
        end
    end
end
