#define DROPS_PERSEC_MIN  10
#define DROPS_PERSEC_MAX 100
#define DROPS_DECAY_MS 2000
#define DROPS_LEN 2

code/await Drop (var IPhysics&& cloud)
                    => (var& IPhysics drop, var& int collisions_n)
                        => void
do
    var int collisions_n_ = 0;
    collisions_n = &collisions_n_;

    var SDL_Rect rct = val SDL_Rect((_rand()%cloud:x.len + cloud:x.pos) as int,
                                    (cloud:y.pos + cloud:y.len) as int,
                                    DROPS_LEN,
                                    5);
    var float vx = cloud:x.vel;

    var& IPhysics drop_;
    spawn Physics(rct, SDL_Color(0x98, 0xC1, 0xE4, 0))
            => (drop_);
    drop = &drop_;
    drop_.x.vel  = vx;
    drop_.x.drag = 0.98;
    drop_.y.drag = 0.98;
    drop_.y.acc  = 500;

    event void decay;
    par/or do
        var int dt;
        every dt in SDL_DT do
            if drop_.y.pos > WIN_H-DROPS_LEN then
                drop_.y.pos = WIN_H-DROPS_LEN;
                drop_.y.vel = -(drop_.y.vel*2/3);
				collisions_n_ = collisions_n_ + 1;
                emit decay;
            end
            if (drop_.x.pos > WIN_W) or (drop_.x.pos < 0) or (drop_.y.pos < 0) then
                break;
            end

            var int abs_vx = _abs(drop_.x.vel);
            var int abs_vy = _abs(drop_.y.vel);
            if abs_vx > abs_vy then
                drop_.x.len = DROPS_LEN * (1 + (abs_vx-abs_vy)/100);
                drop_.y.len = DROPS_LEN;
            else
                drop_.x.len = DROPS_LEN;
                drop_.y.len = DROPS_LEN * (1 + (abs_vy-abs_vx)/100);
            end

            var int tmax = DROPS_LEN * 4;
            if drop_.x.len > tmax then
                drop_.x.len = tmax;
            end
            if drop_.y.len > tmax then
                drop_.y.len = tmax;
            end
        end
    with
        await decay;
        await (DROPS_DECAY_MS)ms;
    end
end
pool[] Drop  drops;

code/await Cloud (var int dps)
                    => (var& IPhysics cloud, var& int dps_out, event& void go_blink)
                        => FOREVER
do
    dps_out = &dps;

    event void go_blink_;
    go_blink = &go_blink_;

    var int maxy = 2 * 1000 / DROPS_PERSEC_MIN;

    var int freq_ini = 1000 / dps;
    var int freq_cur = freq_ini;
    var int ty = maxy - freq_cur*2;
    if ty < 1 then
        ty = 1;
    end

    var int w = 100 + _rand()%100;
    var SDL_Rect rct = val SDL_Rect(-w, ty, 100+_rand()%100, 20+_rand()%50);

    var int v = 200 - (200*ty / maxy);
    var SDL_Color clr = val SDL_Color(v, (v*0.95) as int, v, 0);

    var int vx = 10 + _rand()%50;

    var& IPhysics cloud_;
    spawn Physics(rct, clr) => (cloud_);
    cloud = &cloud_;

    cloud_.x.vel = vx;
    par do
        var int dt;
        every dt in SDL_DT do
            if cloud_.x.pos > WIN_W then
                cloud_.x.pos = -cloud_.x.len;
            end
        end
    with
        every (freq_cur)ms do
            spawn Drop(&&cloud_) in outer.drops;
        end
    with
		loop do
			await go_blink_;
			var SDL_Color old = cloud_.clr;
			cloud_.clr = val SDL_Color(0xFF, 0xFF, 0xFF, 0);
			await 100ms;
            cloud_.clr = old;
		end
    with
        every 50ms do
            freq_ini = 1000 / dps;
            if freq_ini == freq_cur then
                continue;
            end

            if _abs(freq_ini - freq_cur) < 1 then
                freq_cur = freq_ini;
            else/if (freq_ini - freq_cur) > 0 then
                freq_cur = freq_cur + 1;
            else
                freq_cur = freq_cur - 1;
            end

            ty = maxy - freq_cur*2;
            if ty < 1 then
                ty = 1;
            end
            cloud_.y.pos = ty;
            cloud_.clr = val SDL_Color(200-(200*ty/maxy),
                                       ((cloud_.clr.r as int)*0.95) as u8,
                                       cloud_.clr.r,
                                       cloud_.clr.a);
        end
    end
end
pool[] Cloud clouds;

code/await Boom (var int x) => void
do
    var int radius = 80;
    var SDL_Rect rct = val SDL_Rect(x - radius,
                                    (WIN_H + radius*0.2 - radius) as int,
                                    radius*2,
                                    radius*2);

    //_Mix_PlayChannel(-1, outer.snd_explosion, 0);
    watching 100ms do
        every SDL_REDRAW do
            _SDL_SetRenderDrawColor(&&outer.ren, 0xFF, 0x9D, 0x46, 0x00);
            _SDL_RenderFillRect(&&outer.ren, (&&rct as _SDL_Rect&&));
        end
#if 0
        par do
            var float d = DIM;
            var float v = 40 * DIM;
            var int dt;
            every dt in SDL_DT do
                d = d + v*dt/1000;
                obj.rect.w = d as int;
                obj.rect.h = d as int;
            end
        with
            every SDL_REDRAW do
                _filledCircleRGBA(outer.ren, obj.rect.x,obj.rect.y,obj.rect.w,
                                             0xFF,0x00,0x00,0xFF);
            end
        end
#endif
    end

end
pool[] Boom  booms;

code/await Light (pool&[] Light    lights,
                  var     Vector2D pos_ini,
                  var     int?     direction,
                  var     int?     magnitude,
                  var     bool?    is_fork,
                 ) => void
do
    var int dir = 270;
    if direction? then
        dir = direction!;
    end

    var int mag = 50;
    if magnitude? then
        mag = magnitude!;
    end

    var bool fork = false;
    if is_fork? then
        fork = is_fork!;
    end

    var int chaos = 30;
	var float d = PI * (dir - chaos + _rand()%(chaos*2)) / 180.0;
    var Vector2D pos_end = val Vector2D(pos_ini.x + (_cos(d) * mag),
	                                    pos_ini.y - (_sin(d) * mag));

    watching 150ms do
        par do
            if pos_end.y >= WIN_H then
                if not fork then
                    spawn Boom((pos_ini.x + pos_end.x)/2) in outer.booms;
                end
            else/if mag > 5 then
                await 20ms;

                var int m = mag;
                if fork then
                    m = (mag * 0.75) as int;
                end
                spawn Light(&lights, pos_end, dir, m, fork) in lights;

                if (_rand()%WIN_H) > pos_ini.y then
                    spawn Light(&lights, pos_ini, _rand()%180+180, (mag*0.5) as int, true)
                        in lights;
                end
            end
            await FOREVER;
        with
            every SDL_REDRAW do
                _SDL_SetRenderDrawColor(&&outer.ren, 0xEA, 0xD7, 0xFF, 0 );
                _SDL_RenderDrawLine(&&outer.ren,
                                    pos_ini.x, pos_ini.y,
                                    pos_end.x, pos_end.y);
            end
        end
    end
end
pool[] Light lights;

code/await Clouds (void) => void
do
    var int dps_cur = 0;

    loop i in [0 -> 3[ do
        var int dps = (_rand() % (DROPS_PERSEC_MAX+1-dps_cur)) + DROPS_PERSEC_MIN;
        dps_cur = dps_cur + dps;
        if dps_cur > DROPS_PERSEC_MAX then
            dps_cur = DROPS_PERSEC_MAX;
        end
        spawn Cloud(dps) in outer.clouds;
    end

    every (_rand()%10 + 1)s do
        var& int dps_cloud;
        loop (_,dps_cloud,_) in outer.clouds do
            if _rand()%3 == 0 then
                continue;
            end

            dps_cur = dps_cur - dps_cloud;
            if dps_cur < DROPS_PERSEC_MIN then
                dps_cur = DROPS_PERSEC_MIN;
            end

            var int dps = _rand()%(DROPS_PERSEC_MAX+1-dps_cur) + DROPS_PERSEC_MIN;
            dps_cur = dps_cur + dps;
            if dps_cur > DROPS_PERSEC_MAX then
                dps_cur = DROPS_PERSEC_MAX;
            end

            dps_cloud = dps;
        end
        _printf("\nGotas por Segundo atual: %d/%d\n",dps_cur,DROPS_PERSEC_MAX);
    end
end
